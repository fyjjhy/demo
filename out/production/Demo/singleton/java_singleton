双重检查锁定
问题是并不能保证他会在单处理器或多处理器计算机上顺利运行
双重检查锁定失败的问题归咎于Java平台内存模型，内存模型允许所谓的"无序写入"。
无序写入问题:
https://blog.csdn.net/chenchaofuck1/article/details/51702129/
单例模式
特点:
1.单例类只能由一个实例
2.单例类必须自己创建自己的唯一实例(?)
3.单例类必须给所有其他对象提供这一实例
类通过将其构造方法限定为private来避免类在外部被实例化。
通过Java反射机制是可以实例化构造方法为private的类的。
----------------------------------------------------
2019-03-04 22:55:15
懒汉式单例:在第一次调用的时候实例化自己
饿汉式单例:在类初始化时，已经自行实例化
饿汉式单例与懒汉式单例区别
饿汉式单例:类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的
懒汉式单例:只有当调用getInstance的时候，才会去初始化单例
1.线程安全
饿汉式单例可以直接用于多线程
懒汉式单例是非线程安全的
2.资源加载和性能
饿汉式单例:在类创建的同时就实例化一个静态对象出来，不管之后会不会使用单例，都会占据一定的内存，但是相应的，第一次调用
时速度也会更快，因为其资源已经初始化完成
懒汉式单例:会延迟加载，在第一次使用该单例的时候才会实例化对象，第一次调用时要做初始化，如果要做的工作比较多，性能上
会有些延迟
第一种懒汉式单例是在静态方法上添加同步锁
第二种懒汉式单例采用双重检查锁定
第三种懒汉式单例采用静态内部类
1.虽然线程安全，但是每次都要同步，会影响性能
2.确保只有在第一次调用单例的时候进行同步
3.利用classLoader机制保证初始化instance时只有一个线程，同时没有性能损耗
什么是线程安全?
代码所在进程中有多个线程同时运行，而这些线程可能会同时运行这段代码，如果每次运行结果与单线程一致，
而且其他变量的值也和预期一样，就是线程安全的
或者说:
一个类或者程序提供的接口对于线程来说是原子操作，或者多线程之间的切换不会导致该接口的执行效果存在二义性，
也就是不用考虑同步问题，那就是线程安全的
----------------------------------------
2019-03-04 23:21:59
volatile关键字
volatile关键字与Java内存模型有关


