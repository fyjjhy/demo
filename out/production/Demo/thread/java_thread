-------------------------------
2019-03-06 22:07:58
synchronized和实现同步访问
如果获取锁的线程由于要等待IO或者其他原因(比如调用sleep方法)被阻塞了，但是又没有释放锁，其他线程便只能等待。
通过lock可以知道线程有没有获取到锁，这是synchronized无法办到的
--------------------------------------------------------------
2019-03-07 22:42:28
使用synchronized获得多个锁的时候，必须以相反的顺序释放
同步代码块与同步函数的区别?
同步代码块使用的锁可以是任意对象。
同步函数用的锁是this，静态同步函数用的锁是该类的字节码文件对象。
Lock接口中并没有直接操作等待唤醒的方法，而是将这些方法又单独封装到一个对象中，
这个对象就是Condition，经Object中的方法进行单独封装，并提供功能一致的方法await()、
signal()、signalAll()。
同步是隐士的锁操作，而Lock对象是显示的锁操作。
-------------------------------------------
2019-03-08 08:44:46
读写锁:允许多个线程并发的访问共享资源。
使用Lock的固定格式:
Lock lock = ...;
lock.lock();
try {
  // access the resource protected by this lock
} finally { // 必须使用try，最后在finally里面释放锁
  lock.unlock();
}
不要将获取锁的过程写在try块中，因为如果在获取锁(自定义锁的实现)时发生了异常，异常抛出的同时，也会导致锁无故释放。
一般情况下，读写锁的性能比排它锁好。
读锁与写锁是互斥的。
独占访问，并发访问，读锁。
手牵手，链锁方式。
非阻塞的获取锁:tryLock()
中断获取锁:lockInterruptibly()
超时获取锁:tryLock(long, TimeUnit)
volatile修饰变量，保证可见性，并不保证原子性。
synchronized和Lock都具备可重入性。


