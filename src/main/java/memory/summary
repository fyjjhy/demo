堆中的内容有：对象和数组等；
堆创建的时期：jvm启动的时候；
堆中由存活和死亡的对象组成，主要区别在于存活的可以被访问，死亡的虽然还在堆中，但已经不可访问；
【注意】
JDK1.8中，永久代已经从Java堆中移除，String直接存放在堆中，类的元数据存储在meta space中，
meta space占用外部内存，不占用堆内存。
可以说，在Java8的新版本中，持久代已经更名为元空间(meta space)。
【链接地址】
https://www.cnblogs.com/yonyong/p/9334279.html
[JVM知识点]
http://www.sohu.com/a/245293459_661203
[方法区]
方法区：与Java堆一样，是各个线程共享的内存区域。
方法区存储：已被Java虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。
【类信息】
对每个加载的类型(类class、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下信息：
1.这个类型的完整有效名称(全名=包名.类名)
2.这个类型直接父类的完整有效名称(java.lang.Object除外，其他类型若没有声明父类，默认父类是Object)
3.这个类型的修饰符(public、abstract、final的某个子集)
4.这个类型直接接口的一个有序列表
5.类型的常量池(constant pool)
6.域(Field)信息
7.方法(Method)信息
8.除了常量外的所有静态(static)变量
【常量】
1.static final 修饰的成员变量都存储于方法区(Method Area)中
【静态变量】
1.静态变量又称为类变量，类中被static修饰的成员变量都是静态变量(类变量)
2.静态变量之所以又称为类变量，是因为静态变量和类关联在一起，随着类的加载而存在于方法区中(而不是堆中)
3.八种基本数据类型的静态变量会在方法区开辟空间，并将对应的值存储在方法区，
对于引用类型的静态变量如果未用new关键字为引用类型的静态变量分配对象，那么对象的引用会存储在方法区中，并为其指定默认值；
对于引用类型的静态变量如果用new关键字为引用类型的静态变量分配对象，那么对象的引用会存储在方法区中，并且该对象在
堆中的地址也会存储在方法区中(注意：此时静态变量只存储了对象的堆地址，而对象本身仍在堆内存中)
【方法】
1.程序运行时会加载类编译生成的字节码，这个过程中静态变量(类变量)和静态方法及普通方法对应的字节码加载到方法区
2.方法区中没有实例变量，这是因为类加载先于对应类对象的产生，而实例变量是和对象关联在一起的，
没有对象就不存在实例变量，类加载时没有对象，所以方法区中没有实例变量
3.静态变量(类变量)和静态方法及普通方法在方法区存储方式是有区别的
[栈]
栈：线程私有的内存区域
1.每个方法执行时，都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口信息等
2.栈中所存储的变量和引用都是局部的(即：定义在方法体中的变量或者引用)，局部变量和引用都在栈中(包括final修改的局部变量)
3.八种基本数据类型的局部变量(定义在方法体中的基本数据类型的变量)在栈中存储的是它们对应的值
4.栈中还存储局部的对象的引用(定义在方法体中的引用类型的变量)，对象的引用并不是对象本身，而是对象在堆中的地址，
换句话说，局部的对象的引用所指对象在堆中的地址存储在了栈中。当然，如果对象的引用没有指向具体的对象，对象的引用则是null
[堆]
Java堆：被所有线程共享的一块内存区域，在虚拟机启动时创建。
【目的】
存放对象实例。
所有的对象实例及数组都要在Java堆上分配内存空间。
1.由new关键字产生的所有对象都存储于Java堆
2.实例变量(非static修改的成员变量)和对象关联在一起，所以实例变量也在堆中
3.Java数组也在堆中开辟内存空间

【堆|栈】
递归调用可以导致栈溢出。
不断创建对象可以导致堆溢出。
